<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <style>
            body {
                background-color: #222;
                font-family: Arial, Helvetica, sans-serif;
                color: #fff;
                text-align: center;
            }
            canvas {
                width: 100%;
                height: 100%;
                user-select: none;
            }
            .canvas-container {
                display: inline-block;
                position: relative;
                margin-top: 2rem;
                width: 90%;
                border: 1px solid #fff;
            }
            .grid-line {
                position: absolute;
                background-color: #fff;
                pointer-events: none;
            }
            .grid-line.horizontal {
                left: 0;
                width: 100%;
                height: 1px;
            }
            .grid-line.vertical {
                top: 0;
                width: 1px;
                height: 100%;
            }
            .degree-slider {
                margin-top: 1.5rem;
            }
            .display {
                position: absolute;
                bottom: 0.5rem;
                right: 0.5rem;
                font-size: 14px;
                text-shadow: -1px 0 black, 0 1px black, 1px 0 black, 0 -1px black;
                text-align: right;
                pointer-events: none;
            }
        </style>
    </head>
<body>

    <h1>World map</h1>

    <div class="canvas-container">
        <div class="display">
            <div>
                <span id="height-display">0</span> H
            </div>
            <div>
                <span id="width-display">0</span> W
            </div>
            <div>
                <span id="x-degree-display">0</span>&deg; X
            </div>
            <div>
                <span id="y-degree-display">0</span>&deg; Y
            </div>
            <div>
                <span id="z-degree-display">0</span>&deg; Z
            </div>
            <div>
                <span id="scale-display">1.00</span> S
            </div>
        </div>
        <div class="grid-line horizontal" style="top: 50%"></div>
        <div class="grid-line vertical" style="left: 25%;"></div>
        <div class="grid-line vertical" style="left: 50%;"></div>
        <div class="grid-line vertical" style="left: 75%;"></div>
        <canvas></canvas>
    </div>

    <div>
        <div>
            X <input id="x-degree-slider" class="degree-slider" type="range" min="0" max="360" value="0">
            Y <input id="y-degree-slider" class="degree-slider" type="range" min="0" max="360" value="0">
            Z <input id="z-degree-slider" class="degree-slider" type="range" min="0" max="360" value="0">
        </div>
    </div>

    <pre id="log" style="text-align: left;"></pre>

    <script id="vertex-shader" type="notjs">  
  
        attribute vec4 a_position;
        uniform mat4 u_matrix;

        void main() {
            gl_Position = u_matrix * a_position;
        }

    </script>
    
    <script id="fragment-shader" type="notjs">
    
        precision mediump float;
        uniform vec4 u_color;

        void main() {
            gl_FragColor = u_color;
        }

    </script>

    <script src="./data.js"></script>
    <script src="./geojson.js"></script>
    <script src="./earcut.min.js"></script>
    <script src="./gl-matrix.js"></script>
    <script src="./topojson-client.js"></script>
    <script src="./map-colorizer.js"></script>
    <script>

        // The good ol' pythagoras theorem, replace with Math.hypot(x2-x1, y2-y1) + polyfill?
        function hypotenuse(a, b) {
            var x = a[0] - b[0];
            var y = a[1] - b[1];
            return Math.sqrt(x * x + y * y);
        }

        class GreedyColorizer {
            constructor(neighbors) {
                const colors = [...Array(neighbors.length)];
                this.colorCount = 0;
                for(let feature = 0; feature < neighbors.length; feature++) {
                    colors[feature] = 0;
                    for(let n = 0; n < neighbors[feature].length; n++) {
                        const neighbor = neighbors[feature][n];
                        if(colors[neighbor] !== undefined) {
                            colors[feature] = Math.max(colors[feature], colors[neighbor] + 1);
                        }
                    }
                    this.colorCount = Math.max(colors[feature], this.colorCount);
                }
                this.colorCount++;
                this.colors = colors;
            }
        }

        class Color {

            static shade(color, percent) {   
                const t = percent < 0 ? 0 : 255;
                const p = percent < 0 ? percent * -1 : percent;
                const rgb = this.rgb(color);
                return "#" + (0x1000000 +
                    (Math.round((t - rgb.r) * p) + rgb.r) * 0x10000 +
                    (Math.round((t - rgb.g) * p) + rgb.g) * 0x100 +
                    (Math.round((t - rgb.b) * p) + rgb.b)
                ).toString(16).slice(1);
            }

            static rgb(color) {
                const i = parseInt(color.slice(1), 16);
                return {
                    r: i >> 16,
                    g: i >> 8 & 0x00FF,
                    b: i & 0x0000FF
                };
            }

            static vec4(color, a) {
                const rgb = this.rgb(color);
                return [
                    rgb.r / 255,
                    rgb.g / 255,
                    rgb.b / 255,
                    a || 1
                ];
            }
        }

        var scaleDisplay = document.querySelector("#scale-display");
        var xDegreeSlider = document.querySelector("#x-degree-slider");
        var xDegreeDisplay = document.querySelector("#x-degree-display");
        var yDegreeSlider = document.querySelector("#y-degree-slider");
        var yDegreeDisplay = document.querySelector("#y-degree-display");
        var zDegreeSlider = document.querySelector("#z-degree-slider");
        var zDegreeDisplay = document.querySelector("#z-degree-display");

        var logDisplay = document.querySelector("#log");

        var pointSize = 2;
        var featureCollection = topojson.feature(data, data.objects.world);
        //var featureCollection = topojson.feature(geojson, geojson.objects.items);
        var buffer = createBuffer(featureCollection.features);

        var canvas = document.querySelector("canvas");
        var gl = canvas.getContext("webgl");
        var vertexShader = createShader(gl.VERTEX_SHADER, document.getElementById("vertex-shader").text);
        var fragmentShader = createShader(gl.FRAGMENT_SHADER, document.getElementById("fragment-shader").text);
        var program = createProgram(vertexShader, fragmentShader);

        var positionLocation = gl.getAttribLocation(program, "a_position");
        var matrixLocation = gl.getUniformLocation(program, "u_matrix");
        var colorLocation = gl.getUniformLocation(program, "u_color");
        
        var projectionMatrix = mat4.create();
        var viewMatrix = mat4.create();
        var previousMatrix = mat4.create();
        var xRotationMatrix = mat4.create();
        var yRotationMatrix = mat4.create();
        var zRotationMatrix = mat4.create();
        var scaleMatrix = mat4.create();
        var dragMatrix = mat4.create();
        var viewScaleMatrix = mat4.create();

        var translation = vec3.create();
        var negativeTranslation = vec3.create();

        var xRotation = 0;
        var yRotation = 0;
        var zRotation = 0;
        var scale = vec3.fromValues(1, 1, 1);
        var drag = vec3.create();
        var viewScale = vec3.fromValues(1, 1, 1);

        var gesture;

        var minScale = 0.5;
        var maxScale = 100;

        let t0 = performance.now();

        let features = new mapcolorizer.Rings(featureCollection);
        let neighbors = features.neighbors.values;
        //let neighbors = topojson.neighbors(data.objects.world.geometries);
        //let neighbors = topojson.neighbors(geojson.objects.items.geometries);

        let colorizer = new mapcolorizer.BacktrackingColorizer(neighbors, {
            numberOfColors: 4,
            startIndexIslands: 1,
            maxAttempts: 5000,
            path: new mapcolorizer.Path(neighbors, 3)
        });

        var palette = [];

        let color = "#00ff00";
        let shade = -0.4;
        for(let i = 0; i < colorizer.colorCount; i++) {
            palette.push(Color.shade(color, shade));
            shade += 0.3;
        }

        var colors = colorizer.colors.map((color) => {
            return Color.vec4(palette[color] || "#ff11aa");
        });

        let t1 = performance.now();
        console.log("Coloring took " + (t1 - t0) + " milliseconds and used " + colorizer.colorCount + " colors, problem solved: " + colorizer.solved + ", attempts: " + colorizer.attempts);

        gl.useProgram(program);
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(buffer.data), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, pointSize, gl.FLOAT, false, 0, 0);

        xDegreeSlider.addEventListener("input", function(e) {
            requestAnimationFrame(function() {
                xRotation = e.target.valueAsNumber;
                xDegreeDisplay.innerHTML = xRotation;
                render();
            });
        });

        yDegreeSlider.addEventListener("input", function(e) {
            requestAnimationFrame(function() {
                yRotation = e.target.valueAsNumber;
                yDegreeDisplay.innerHTML = yRotation;
                render();
            });
        });

        zDegreeSlider.addEventListener("input", function(e) {
            requestAnimationFrame(function() {
                zRotation = e.target.valueAsNumber;
                zDegreeDisplay.innerHTML = zRotation;
                render();
            });
        });

        function mousePoint(event, mouse) {
            var rect = gl.canvas.getBoundingClientRect();
            mouse[0] = (event.clientX - rect.left) * (gl.canvas.width / rect.width);
            mouse[1] = (event.clientY - rect.top) * (gl.canvas.height / rect.height);
            return mouse;
        }

        function noevent(e) {
            e.preventDefault();
            e.stopImmediatePropagation();
        }

        canvas.addEventListener("mousedown", function(e) {
            if(e.button !== 0) {
                return;
            }
            canvas.addEventListener("mousemove", mousemove);
            canvas.addEventListener("mouseup", mouseup);
            canvas.addEventListener("dragstart", noevent);
            noevent(e);

            var mouse = mousePoint(e, vec2.create());
            mouse[0] -= drag[0];
            mouse[1] -= drag[1];

            function mousemove(e) {
                noevent(e);
                requestAnimationFrame(function() {
                    var delta = mousePoint(e, vec2.create());
                    drag[0] = delta[0] - mouse[0];
                    drag[1] = delta[1] - mouse[1];
                    render();
                });
            }

            function mouseup(e) {
                canvas.removeEventListener("mousemove", mousemove);
                canvas.removeEventListener("mouseup", mouseup);
                canvas.removeEventListener("dragstart", noevent);
                noevent(e);
            }
        });

        /*
        var logItems = [];
        function log(obj) {

            logItems.unshift( { obj: obj, date: new Date() });

            if(logItems.length > 10) {
                logItems.length = 10;
            }

            var out = "";
            for (var i = logItems.length - 1; i >= 0; --i) {
                var item = logItems[i];
                out += item.date.getHours().toString().padStart(2, "0") + ":"
                + item.date.getMinutes() .toString().padStart(2, "0")+ ":"
                + item.date.getSeconds().toString().padStart(2, "0") + ":"
                + item.date.getMilliseconds().toString().padStart(3, "00")
                    + " " + JSON.stringify(item.obj, null, 2) + "\n";
            }

            logDisplay.innerHTML = out;
        }
        */

        canvas.addEventListener("touchstart", function(e) {

            noevent(e);

            gesture = {};
            
            for(let t of e.touches) {
                if(!gesture.finger1) {
                    gesture.finger1 = {
                        origin: mousePoint(t, vec2.create()),
                        id: t.identifier
                    }
                }
                else if(!gesture.finger2) {
                    gesture.finger2 = {
                        origin: mousePoint(t, vec2.create()),
                        id: t.identifier
                    }
                    gesture.distance = hypotenuse(gesture.finger1.origin, gesture.finger2.origin);
                }
            }

            if(gesture.finger1 && !gesture.finger2) {
                gesture.finger1.origin[0] -= drag[0];
                gesture.finger1.origin[1] -= drag[1];
            }
        });

        canvas.addEventListener("touchmove", function(e) {

            noevent(e);

            for(let t of e.touches) {
                if(gesture.finger1.id === t.identifier) {
                    gesture.finger1.current = mousePoint(t, vec2.create());
                }
                else if(gesture.finger2.id === t.identifier) {
                    gesture.finger2.current = mousePoint(t, vec2.create());
                }
            }

            if(gesture.finger2) {
                const distance = hypotenuse(gesture.finger1.current, gesture.finger2.current);
                const delta = distance - gesture.distance
                gesture.distance = distance

                translation[0] = (gesture.finger1.origin[0] + gesture.finger2.origin[0]) / 2;
                translation[1] = (gesture.finger1.origin[1] + gesture.finger2.origin[1]) / 2;

                zoom(delta / 500);
            }
            else if(gesture.finger1) {
                drag[0] = gesture.finger1.current[0] - gesture.finger1.origin[0];
                drag[1] = gesture.finger1.current[1] - gesture.finger1.origin[1];
                render();
            }
        });

        canvas.addEventListener("touchend", function(e) {
            gesture = {};
            noevent(e);
        });

        canvas.addEventListener("click", function(e) {
            var mouse = vec4.fromValues(0, 0, 0, 1);
            mousePoint(e, mouse);
            vec4.transformMat4(mouse, mouse, mat4.invert([], viewMatrix));
            console.log(mouse);
        });

        canvas.addEventListener("wheel", function(e) {
            noevent(e);
            requestAnimationFrame(function() {
                mousePoint(e, translation);
                zoom(-e.deltaY * (e.deltaMode ? 120 : 1) / 500);
            });
        });

        window.addEventListener("resize", resize);

        resize();

        function zoom(delta) {
            scale[0] = scale[1] = Math.max(minScale, Math.min(maxScale, scale[0] * Math.pow(2, delta)));
            scaleDisplay.innerHTML = scale[0].toFixed(2);
            render();
        }

        function resize() {
            var aspectRatio = gl.canvas.height / gl.canvas.width;
            var width = gl.canvas.parentElement.clientWidth * window.devicePixelRatio;
            var height = (width * aspectRatio);
            gl.canvas.width = width;
            gl.canvas.height = height;
            gl.viewport(0, 0, width, height);

            viewScale[0] = viewScale[1] = gl.canvas.width / data.bbox[2];
            translation = vec3.fromValues(gl.canvas.width / 2, gl.canvas.height / 2, 0);

            document.querySelector("#height-display").innerHTML = height;
            document.querySelector("#width-display").innerHTML = width;

            render();
        }

        function calculateMatrix() {
            mat4.copy(previousMatrix, viewMatrix);
            mat4.identity(viewMatrix);
            
            mat4.translate(viewMatrix, viewMatrix, translation);

            mat4.multiply(viewMatrix, viewMatrix, mat4.invert(xRotationMatrix, xRotationMatrix));
            mat4.multiply(viewMatrix, viewMatrix, mat4.fromXRotation(xRotationMatrix, glMatrix.toRadian(xRotation)));

            mat4.multiply(viewMatrix, viewMatrix, mat4.invert(yRotationMatrix, yRotationMatrix));
            mat4.multiply(viewMatrix, viewMatrix, mat4.fromYRotation(yRotationMatrix, glMatrix.toRadian(yRotation)));

            mat4.multiply(viewMatrix, viewMatrix, mat4.invert(zRotationMatrix, zRotationMatrix));
            mat4.multiply(viewMatrix, viewMatrix, mat4.fromZRotation(zRotationMatrix, glMatrix.toRadian(zRotation)));

            mat4.multiply(viewMatrix, viewMatrix, mat4.invert(scaleMatrix, scaleMatrix));
            mat4.multiply(viewMatrix, viewMatrix, mat4.fromScaling(scaleMatrix, scale));

            mat4.multiply(viewMatrix, viewMatrix, mat4.invert(dragMatrix, dragMatrix));
            mat4.multiply(viewMatrix, viewMatrix, mat4.fromTranslation(dragMatrix, drag));

            mat4.translate(viewMatrix, viewMatrix, vec3.negate(negativeTranslation, translation));

            mat4.multiply(viewMatrix, viewMatrix, mat4.invert(viewScaleMatrix, viewScaleMatrix));
            mat4.multiply(viewMatrix, viewMatrix, mat4.fromScaling(viewScaleMatrix, viewScale));

            mat4.multiply(viewMatrix, viewMatrix, previousMatrix);
        }

        function project() {
            mat4.ortho(projectionMatrix, 0, gl.canvas.width, gl.canvas.height, 0, gl.canvas.height * -2, gl.canvas.height * 2);
            mat4.multiply(projectionMatrix, projectionMatrix, viewMatrix);
        }

        function render() {
    
            calculateMatrix();
            project();

            gl.uniformMatrix4fv(matrixLocation, false, projectionMatrix);
            gl.clear(gl.COLOR_BUFFER_BIT);

            var offset = 0;
            for(var i = 0; i < buffer.offsets.length; i++) {
                gl.uniform4fv(colorLocation, colors[i]);
                gl.drawArrays(gl.TRIANGLES, offset, buffer.offsets[i] / pointSize);
                offset += buffer.offsets[i] / pointSize;
            }
        }

        function createShader(type, source) {
            var shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            if (!success) {
                gl.deleteShader(shader);
                throw new Error(gl.getShaderInfoLog(shader));
            }
            return shader;
        }

        function createProgram(vertexShader, fragmentShader) {
            var program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            gl.getProgramParameter(program, gl.LINK_STATUS);
            var success = gl.getProgramParameter(program, gl.LINK_STATUS);
            if (!success) {
                gl.deleteProgram(program);
                throw new Error(gl.getProgramInfoLog(program));
            }
            return program;
        }

        function createBuffer(features) {

            var buffer = { data: [], offsets: [] };
            var offset = 0;

            features.forEach(function(feature) {
                if(feature.geometry.type === "Polygon") {                    
                    triangulate(feature.geometry.coordinates, buffer.data);
                }
                if(feature.geometry.type === "MultiPolygon") {
                    for(let coordinates of feature.geometry.coordinates) {
                        triangulate(coordinates, buffer.data);
                    }
                }
                buffer.offsets.push(buffer.data.length - offset);
                offset = buffer.data.length;
            });

            return buffer;
        }

        function triangulate(polygons, data) {
            var points = earcut.flatten(polygons);
            var triangles = earcut(points.vertices, points.holes, points.dimensions);
            triangles.forEach(function(t) {
                var i = t * pointSize;
                data.push(points.vertices[i], points.vertices[i + 1]);
            });
        }

    </script>
</body>
</html>
