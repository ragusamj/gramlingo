<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
        <style>
            body {
                background-color: #222;
                font-family: Arial, Helvetica, sans-serif;
                color: #fff;
                text-align: center;
            }
            canvas {
                width: 100%;
                height: 100%;
                user-select: none;
            }
            .canvas-container {
                display: inline-block;
                position: relative;
                margin-top: 2rem;
                width: 90%;
                border: 1px solid #fff;
            }
            .grid-line {
                position: absolute;
                background-color: #fff;
                pointer-events: none;
            }
            .grid-line.horizontal {
                left: 0;
                width: 100%;
                height: 1px;
            }
            .grid-line.vertical {
                top: 0;
                width: 1px;
                height: 100%;
            }
            .degree-slider {
                margin-top: 1.5rem;
            }
            .display {
                position: absolute;
                bottom: 0.5rem;
                right: 0.5rem;
                font-size: 14px;
                text-shadow: -1px 0 black, 0 1px black, 1px 0 black, 0 -1px black;
                text-align: right;
                pointer-events: none;
            }
        </style>
    </head>
<body>

    <h1>World map</h1>

    <div class="canvas-container">
        <div class="display">
            <div>
                <span id="height-display">0</span> H
            </div>
            <div>
                <span id="width-display">0</span> W
            </div>
            <div>
                <span id="x-degree-display">0</span>&deg; X
            </div>
            <div>
                <span id="y-degree-display">0</span>&deg; Y
            </div>
            <div>
                <span id="z-degree-display">0</span>&deg; Z
            </div>
            <div>
                <span id="scale-display">1.00</span> S
            </div>
        </div>
        <div class="grid-line horizontal" style="top: 50%"></div>
        <div class="grid-line vertical" style="left: 25%;"></div>
        <div class="grid-line vertical" style="left: 50%;"></div>
        <div class="grid-line vertical" style="left: 75%;"></div>
        <canvas></canvas>
    </div>

    <div>
        <div>
            X <input id="x-degree-slider" class="degree-slider" type="range" min="0" max="360" value="0">
            Y <input id="y-degree-slider" class="degree-slider" type="range" min="0" max="360" value="0">
            Z <input id="z-degree-slider" class="degree-slider" type="range" min="0" max="360" value="0">
        </div>
    </div>

    <pre id="log" style="text-align: left;"></pre>

    <script id="vertex-shader" type="notjs">  
  
        attribute vec4 a_position;
        uniform mat4 u_matrix;

        void main() {
            gl_Position = u_matrix * a_position;
        }

    </script>
    
    <script id="fragment-shader" type="notjs">
    
        precision mediump float;
        uniform vec4 u_color;

        void main() {
            gl_FragColor = u_color;
        }

    </script>

    <script src="./data.js"></script>
    <script src="./earcut.min.js"></script>
    <script src="./gl-matrix.js"></script>
    <script src="./topojson-client.js"></script>
    <script>

        class GeoJson {
            static isArray(object) {
                return Array.isArray(object) &&
                       Array.isArray(object[0]) &&
                       Array.isArray(object[0][0]);
            }
        }

        class Neighbors {

            constructor(features) {
                this.values = this.intersect(features);
            }

            intersect(features) {
                return features.map((feature) => {
                    const neighbors = [];
                    for(const shape of feature.shapes) {
                        for(const nfeature of feature.possibleNeighbors) {
                            for(const nshape of nfeature.shapes) {
                                if(nfeature.index !== feature.index && neighbors.indexOf(nfeature.index) === -1 && nshape.intersects(shape)) {
                                    neighbors.push(nfeature.index);
                                }
                            }
                        }
                    }
                    return neighbors;
                });
            }
        }

        class BoundingBox {

            constructor(object) {

                this.x1 = this.y1 = Infinity;
                this.x2 = this.y2 = -Infinity;

                if(GeoJson.isArray(object)) {
                    for(let points of object) {
                        this.reduce(points);
                    }
                }
                else if (Array.isArray(object)) {
                    this.reduce(object);
                }
            }

            reduce(points) {
                for(const point of points) {
                    this.x1 = Math.min(this.x1, point[0]);
                    this.y1 = Math.min(this.y1, point[1]);
                    this.x2 = Math.max(this.x2, point[0]);
                    this.y2 = Math.max(this.y2, point[1]);
                }
            }

            intersects(other) {
                return this.x1 < other.x2 &&
                       this.x2 > other.x1 &&
                       this.y1 < other.y2 &&
                       this.y2 > other.y1;
            }
        }

        class Ring {

            constructor(object) {

                this.points = [];

                if(GeoJson.isArray(object)) {
                    for(const points of object) {
                        this.quantize(points);
                    }
                }
                else if (Array.isArray(object)) {
                    this.quantize(object);
                }
            }

            quantize(points) {
                for(const point of points) {
                    this.points.push([
                        Math.floor(point[0]),
                        Math.floor(point[1])
                    ]);
                }
            }

            intersects(other) {
                for(const t of this.points) {
                    for(const o of other.points) {
                        if(t[0] === o[0] && t[1] === o[1]) {
                            return true;
                        }
                    }
                }
                return false;
            }
        }

        class Features {

            constructor(values, strategy) {
                this.values = this.map(values.features, strategy);
            }

            map(features, strategy) {
                return features.map((f, i) => {
                    const feature = {
                        index: i,
                        shapes: []
                    };
                    if(f.geometry.type === "Polygon") {
                        feature.shapes.push(new strategy(f.geometry.coordinates));
                    }
                    if(f.geometry.type === "MultiPolygon") {
                        for(const coordinates of f.geometry.coordinates) {
                            feature.shapes.push(new strategy(coordinates));
                        }
                    }
                    return feature;
                });
            }
        }

        class BoundingBoxes {
            constructor(featureCollection) {
                const bboxes = new Features(featureCollection, BoundingBox);
                for(const feature of bboxes.values) {
                    feature.possibleNeighbors = bboxes.values;
                }
                this.neighbors = new Neighbors(bboxes.values);
            }
        }

        class Rings {
            constructor(featureCollection) {
                const bboxes = new BoundingBoxes(featureCollection);
                const rings = new Features(featureCollection, Ring);
                let i = 0;
                for(const feature of rings.values) {
                    feature.possibleNeighbors = bboxes.neighbors.values[i].map((n) => {
                        return rings.values[n];
                    });
                    i++;
                }
                this.neighbors = new Neighbors(rings.values);
            }
        }

        class Greedy {
            constructor(neighbors) {
                const colors = [...Array(neighbors.length)];
                this.colorCount = 0;
                for(let feature = 0; feature < neighbors.length; feature++) {
                    colors[feature] = 0;
                    for(let n = 0; n < neighbors[feature].length; n++) {
                        const neighbor = neighbors[feature][n];
                        if(colors[neighbor] !== undefined) {
                            colors[feature] = Math.max(colors[feature], colors[neighbor] + 1);
                        }
                    }
                    this.colorCount = Math.max(colors[feature], this.colorCount);
                }
                this.colorCount++;
                this.colors = colors;
            }
        }

        class Color {

            static shade(color, percent) {   
                const t = percent < 0 ? 0 : 255;
                const p = percent < 0 ? percent * -1 : percent;
                const rgb = this.rgb(color);
                return "#" + (0x1000000 +
                    (Math.round((t - rgb.r) * p) + rgb.r) * 0x10000 +
                    (Math.round((t - rgb.g) * p) + rgb.g) * 0x100 +
                    (Math.round((t - rgb.b) * p) + rgb.b)
                ).toString(16).slice(1);
            }

            static rgb(color) {
                const i = parseInt(color.slice(1), 16);
                return {
                    r: i >> 16,
                    g: i >> 8 & 0x00FF,
                    b: i & 0x0000FF
                };
            }

            static vec4(color, a) {
                const rgb = this.rgb(color);
                return [
                    rgb.r / 255,
                    rgb.g / 255,
                    rgb.b / 255,
                    a || 1
                ];
            }
        }

        /*
        let bbox = new BoundingBox([[0,0], [1,0], [0,2], [0,0]]);
        let bbox2 = new BoundingBox([[3,3], [4,3], [4,4], [3,3]]);
        console.log(bbox.x1, bbox.y1, bbox.x2, bbox.y2);  // {x1: 0,   y1: 0,   x2: 1, y2: 2}
        console.log(bbox.intersects(bbox));
        console.log(bbox.intersects(bbox2));
        */

        var scaleDisplay = document.querySelector("#scale-display");
        var xDegreeSlider = document.querySelector("#x-degree-slider");
        var xDegreeDisplay = document.querySelector("#x-degree-display");
        var yDegreeSlider = document.querySelector("#y-degree-slider");
        var yDegreeDisplay = document.querySelector("#y-degree-display");
        var zDegreeSlider = document.querySelector("#z-degree-slider");
        var zDegreeDisplay = document.querySelector("#z-degree-display");

        var logDisplay = document.querySelector("#log");

        var pointSize = 2;
        var featureCollection = topojson.feature(data, data.objects.world);
        var buffer = createBuffer(featureCollection.features);

        var canvas = document.querySelector("canvas");
        var gl = canvas.getContext("webgl");
        var vertexShader = createShader(gl.VERTEX_SHADER, document.getElementById("vertex-shader").text);
        var fragmentShader = createShader(gl.FRAGMENT_SHADER, document.getElementById("fragment-shader").text);
        var program = createProgram(vertexShader, fragmentShader);

        var positionLocation = gl.getAttribLocation(program, "a_position");
        var matrixLocation = gl.getUniformLocation(program, "u_matrix");
        var colorLocation = gl.getUniformLocation(program, "u_color");
        
        var projectionMatrix = mat4.create();
        var viewMatrix = mat4.create();
        var previousMatrix = mat4.create();
        var xRotationMatrix = mat4.create();
        var yRotationMatrix = mat4.create();
        var zRotationMatrix = mat4.create();
        var scaleMatrix = mat4.create();
        var dragMatrix = mat4.create();
        var viewScaleMatrix = mat4.create();

        var translation = vec3.create();
        var negativeTranslation = vec3.create();

        var xRotation = 0;
        var yRotation = 0;
        var zRotation = 0;
        var scale = vec3.fromValues(1, 1, 1);
        var drag = vec3.create();
        var viewScale = vec3.fromValues(1, 1, 1);

        var gesture;

        var minScale = 0.5;
        var maxScale = 10;

        let t0 = performance.now();

        let rings = new Rings(featureCollection);
        let greedy = new Greedy(rings.neighbors.values);

        var palette = [];

        let color = "#aa00ff";
        let shade = -0.5;
        for(let i = 0; i < greedy.colorCount; i++) {
            palette.push(Color.shade(color, shade));
            shade += 0.2;
        }

        var colors = greedy.colors.map((color) => {
            return Color.vec4(palette[color]);
        });

        let t1 = performance.now();
        console.log("Greedy coloring took " + (t1 - t0) + " milliseconds and needed " + greedy.colorCount + " colors");

        gl.useProgram(program);
        gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(buffer.data), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(positionLocation);
        gl.vertexAttribPointer(positionLocation, pointSize, gl.FLOAT, false, 0, 0);

        xDegreeSlider.addEventListener("input", function(e) {
            requestAnimationFrame(function() {
                xRotation = e.target.valueAsNumber;
                xDegreeDisplay.innerHTML = xRotation;
                render();
            });
        });

        yDegreeSlider.addEventListener("input", function(e) {
            requestAnimationFrame(function() {
                yRotation = e.target.valueAsNumber;
                yDegreeDisplay.innerHTML = yRotation;
                render();
            });
        });

        zDegreeSlider.addEventListener("input", function(e) {
            requestAnimationFrame(function() {
                zRotation = e.target.valueAsNumber;
                zDegreeDisplay.innerHTML = zRotation;
                render();
            });
        });

        function mousePoint(event, mouse) {
            var rect = gl.canvas.getBoundingClientRect();
            mouse[0] = (event.clientX - rect.left) * (gl.canvas.width / rect.width);
            mouse[1] = (event.clientY - rect.top) * (gl.canvas.height / rect.height);
            return mouse;
        }

        function noevent(e) {
            e.preventDefault();
            e.stopImmediatePropagation();
        }

        // The good ol' pythagoras theorem, replace with Math.hypot(x2-x1, y2-y1) + polyfill?
        function hypotenuse(a, b) {
            var x = a[0] - b[0];
            var y = a[1] - b[1];
            return Math.sqrt(x * x + y * y);
        }

        canvas.addEventListener("mousedown", function(e) {
            if(e.button !== 0) {
                return;
            }
            canvas.addEventListener("mousemove", mousemove);
            canvas.addEventListener("mouseup", mouseup);
            canvas.addEventListener("dragstart", noevent);
            noevent(e);

            var mouse = mousePoint(e, vec2.create());
            mouse[0] -= drag[0];
            mouse[1] -= drag[1];

            function mousemove(e) {
                noevent(e);
                requestAnimationFrame(function() {
                    var delta = mousePoint(e, vec2.create());
                    drag[0] = delta[0] - mouse[0];
                    drag[1] = delta[1] - mouse[1];
                    render();
                });
            }

            function mouseup(e) {
                canvas.removeEventListener("mousemove", mousemove);
                canvas.removeEventListener("mouseup", mouseup);
                canvas.removeEventListener("dragstart", noevent);
                noevent(e);
            }
        });

        /*
        var logItems = [];
        function log(obj) {

            logItems.unshift( { obj: obj, date: new Date() });

            if(logItems.length > 10) {
                logItems.length = 10;
            }

            var out = "";
            for (var i = logItems.length - 1; i >= 0; --i) {
                var item = logItems[i];
                out += item.date.getHours().toString().padStart(2, "0") + ":"
                + item.date.getMinutes() .toString().padStart(2, "0")+ ":"
                + item.date.getSeconds().toString().padStart(2, "0") + ":"
                + item.date.getMilliseconds().toString().padStart(3, "00")
                    + " " + JSON.stringify(item.obj, null, 2) + "\n";
            }

            logDisplay.innerHTML = out;
        }
        */

        canvas.addEventListener("touchstart", function(e) {

            noevent(e);

            gesture = {};
            
            for(let t of e.touches) {
                if(!gesture.finger1) {
                    gesture.finger1 = {
                        origin: mousePoint(t, vec2.create()),
                        id: t.identifier
                    }
                }
                else if(!gesture.finger2) {
                    gesture.finger2 = {
                        origin: mousePoint(t, vec2.create()),
                        id: t.identifier
                    }
                    gesture.distance = hypotenuse(gesture.finger1.origin, gesture.finger2.origin);
                }
            }

            if(gesture.finger1 && !gesture.finger2) {
                gesture.finger1.origin[0] -= drag[0];
                gesture.finger1.origin[1] -= drag[1];
            }
        });

        canvas.addEventListener("touchmove", function(e) {

            noevent(e);

            for(let t of e.touches) {
                if(gesture.finger1.id === t.identifier) {
                    gesture.finger1.current = mousePoint(t, vec2.create());
                }
                else if(gesture.finger2.id === t.identifier) {
                    gesture.finger2.current = mousePoint(t, vec2.create());
                }
            }

            if(gesture.finger2) {
                const distance = hypotenuse(gesture.finger1.current, gesture.finger2.current);
                const delta = distance - gesture.distance
                gesture.distance = distance

                translation[0] = (gesture.finger1.origin[0] + gesture.finger2.origin[0]) / 2;
                translation[1] = (gesture.finger1.origin[1] + gesture.finger2.origin[1]) / 2;

                zoom(delta / 500);
            }
            else if(gesture.finger1) {
                drag[0] = gesture.finger1.current[0] - gesture.finger1.origin[0];
                drag[1] = gesture.finger1.current[1] - gesture.finger1.origin[1];
                render();
            }
        });

        canvas.addEventListener("touchend", function(e) {
            gesture = {};
            noevent(e);
        });

        canvas.addEventListener("click", function(e) {
            var mouse = vec4.fromValues(0, 0, 0, 1);
            mousePoint(e, mouse);
            vec4.transformMat4(mouse, mouse, mat4.invert([], viewMatrix));
            console.log(mouse);
        });

        canvas.addEventListener("wheel", function(e) {
            noevent(e);
            requestAnimationFrame(function() {
                mousePoint(e, translation);
                zoom(-e.deltaY * (e.deltaMode ? 120 : 1) / 500);
            });
        });

        window.addEventListener("resize", resize);

        resize();

        function zoom(delta) {
            scale[0] = scale[1] = Math.max(minScale, Math.min(maxScale, scale[0] * Math.pow(2, delta)));
            scaleDisplay.innerHTML = scale[0].toFixed(2);
            render();
        }

        function resize() {
            var aspectRatio = gl.canvas.height / gl.canvas.width;
            var width = gl.canvas.parentElement.clientWidth * window.devicePixelRatio;
            var height = (width * aspectRatio);
            gl.canvas.width = width;
            gl.canvas.height = height;
            gl.viewport(0, 0, width, height);

            viewScale[0] = viewScale[1] = gl.canvas.width / data.bbox[2];
            translation = vec3.fromValues(gl.canvas.width / 2, gl.canvas.height / 2, 0);

            document.querySelector("#height-display").innerHTML = height;
            document.querySelector("#width-display").innerHTML = width;

            render();
        }

        function calculateMatrix() {
            mat4.copy(previousMatrix, viewMatrix);
            mat4.identity(viewMatrix);
            
            mat4.translate(viewMatrix, viewMatrix, translation);

            mat4.multiply(viewMatrix, viewMatrix, mat4.invert(xRotationMatrix, xRotationMatrix));
            mat4.multiply(viewMatrix, viewMatrix, mat4.fromXRotation(xRotationMatrix, glMatrix.toRadian(xRotation)));

            mat4.multiply(viewMatrix, viewMatrix, mat4.invert(yRotationMatrix, yRotationMatrix));
            mat4.multiply(viewMatrix, viewMatrix, mat4.fromYRotation(yRotationMatrix, glMatrix.toRadian(yRotation)));

            mat4.multiply(viewMatrix, viewMatrix, mat4.invert(zRotationMatrix, zRotationMatrix));
            mat4.multiply(viewMatrix, viewMatrix, mat4.fromZRotation(zRotationMatrix, glMatrix.toRadian(zRotation)));

            mat4.multiply(viewMatrix, viewMatrix, mat4.invert(scaleMatrix, scaleMatrix));
            mat4.multiply(viewMatrix, viewMatrix, mat4.fromScaling(scaleMatrix, scale));

            mat4.multiply(viewMatrix, viewMatrix, mat4.invert(dragMatrix, dragMatrix));
            mat4.multiply(viewMatrix, viewMatrix, mat4.fromTranslation(dragMatrix, drag));

            mat4.translate(viewMatrix, viewMatrix, vec3.negate(negativeTranslation, translation));

            mat4.multiply(viewMatrix, viewMatrix, mat4.invert(viewScaleMatrix, viewScaleMatrix));
            mat4.multiply(viewMatrix, viewMatrix, mat4.fromScaling(viewScaleMatrix, viewScale));

            mat4.multiply(viewMatrix, viewMatrix, previousMatrix);
        }

        function project() {
            mat4.ortho(projectionMatrix, 0, gl.canvas.width, gl.canvas.height, 0, gl.canvas.height * -2, gl.canvas.height * 2);
            mat4.multiply(projectionMatrix, projectionMatrix, viewMatrix);
        }

        function render() {
    
            calculateMatrix();
            project();

            gl.uniformMatrix4fv(matrixLocation, false, projectionMatrix);
            gl.clear(gl.COLOR_BUFFER_BIT);

            var offset = 0;
            for(var i = 0; i < buffer.offsets.length; i++) {
                gl.uniform4fv(colorLocation, colors[i]);
                gl.drawArrays(gl.TRIANGLES, offset, buffer.offsets[i] / pointSize);
                offset += buffer.offsets[i] / pointSize;
            }
        }

        function createShader(type, source) {
            var shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            var success = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
            if (!success) {
                gl.deleteShader(shader);
                throw new Error(gl.getShaderInfoLog(shader));
            }
            return shader;
        }

        function createProgram(vertexShader, fragmentShader) {
            var program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            gl.getProgramParameter(program, gl.LINK_STATUS);
            var success = gl.getProgramParameter(program, gl.LINK_STATUS);
            if (!success) {
                gl.deleteProgram(program);
                throw new Error(gl.getProgramInfoLog(program));
            }
            return program;
        }

        function createBuffer(features) {

            var buffer = { data: [], offsets: [] };
            var offset = 0;

            features.forEach(function(feature) {
                if(feature.geometry.type === "Polygon") {                    
                    triangulate(feature.geometry.coordinates, buffer.data);
                }
                if(feature.geometry.type === "MultiPolygon") {
                    for(let coordinates of feature.geometry.coordinates) {
                        triangulate(coordinates, buffer.data);
                    }
                }
                buffer.offsets.push(buffer.data.length - offset);
                offset = buffer.data.length;
            });

            return buffer;
        }

        function triangulate(polygons, data) {
            var points = earcut.flatten(polygons);
            var triangles = earcut(points.vertices, points.holes, points.dimensions);
            triangles.forEach(function(t) {
                var i = t * pointSize;
                data.push(points.vertices[i], points.vertices[i + 1]);
            });
        }

    </script>
</body>
</html>
