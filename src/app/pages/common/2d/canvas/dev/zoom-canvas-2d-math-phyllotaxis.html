<!DOCTYPE html>
<html>
<head>
    <title>Phyllotaxis: Zooming a 2D Canvas with math</title>
</head>
<body style="font-family: Arial, Helvetica, sans-serif; text-align: center;">
    <canvas width="600" height="600"></canvas>
    <div id="debugger"></div>
    <script>

        class Transform {
            constructor(k, x, y) {
                this.k = k;
                this.x = x;
                this.y = y;
            }
            invert(point) {
                return [(point[0] - this.x) / this.k, (point[1] - this.y) / this.k];
            }
            scale(k) {
                this.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
            }
            translate(p0, p1) {
                this.x = p0[0] - p1[0] * this.k;
                this.y = p0[1] - p1[1] * this.k;
            }
        }

        const mouse = (node, event) =>{
            var rect = node.getBoundingClientRect();
            return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
        }

        const canvas = document.querySelector('canvas');
        const context = canvas.getContext('2d');
        const slider = document.querySelector('input');
        const radius = 2.5;

        const scaleExtent = [1/2, 4];
        let t = new Transform(1, 0, 0, 0);

        const render = () => {

            context.save();
            context.clearRect(0, 0, canvas.width, canvas.height);
            context.translate(t.x, t.y);
            context.scale(t.k, t.k);
            context.beginPath();
            points.forEach(drawPoint);
            context.fill();
            context.restore();
        }

        const drawPoint = (point, index) => {
            context.moveTo(point[0] + radius, point[1]);
            context.arc(point[0], point[1], radius, 0, 2 * Math.PI);
        }

        const phyllotaxis = radius => {
            const theta = Math.PI * (3 - Math.sqrt(5));
            return i => {
                const r = radius * Math.sqrt(i), a = theta * i;
                return [
                    canvas.width / 2 + r * Math.cos(a),
                    canvas.height / 2 + r * Math.sin(a)
                ];
            };
        }

        const points = Array
            .from(new Array(2000))
            .map((v, i) => { return i + 1; })
            .map(phyllotaxis(10));

        const noevent = e => {
            e.preventDefault();
            e.stopImmediatePropagation();
        }

        canvas.addEventListener('wheel', e => {
            noevent(e);
            requestAnimationFrame(() => {

                const delta = -e.deltaY * (e.deltaMode ? 120 : 1) / 500;
                const p = mouse(canvas, e);
                const i = t.invert(p);
                t.scale(t.k * Math.pow(2, delta));
                t.translate(p, i);
                
                render();
            });
        });

        canvas.addEventListener('mousedown', e => {
            if(e.button !== 0) { return; }
            noevent(e);

            const p = mouse(canvas, e);
            const i = t.invert(p);

            const mousemove = e => {
                noevent(e);
                t.translate(mouse(canvas, e), i);
                render();
            }

            const mouseup = e => {
                noevent(e);
                canvas.removeEventListener('mousemove', mousemove);
                canvas.removeEventListener('mouseup', mouseup);
            }

            canvas.addEventListener('mousemove', mousemove);
            canvas.addEventListener('mouseup', mouseup);
        });

        canvas.addEventListener("touchstart", function(e) {
            canvas.addEventListener("touchmove", touchmove);
            canvas.addEventListener("touchend", touchend);
            noevent(e);

            const l0 = t.invert(mouse(canvas, e.touches[0]));
            const l1 = t.invert(mouse(canvas, e.touches[1]));

            function touchmove(e) {

                var p0 = mouse(canvas, e.touches[0]),
                    p1 = mouse(canvas, e.touches[1]),

                    dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
                    dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl,

                    p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2],
                    l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];

                t.scale(Math.sqrt(dp / dl));
                t.translate(p, l);

                document.querySelector("#debugger").innerHTML = t.k;

                noevent(e);
                requestAnimationFrame(function() {
                    render();
                });
            }

            function touchend(e) {
                canvas.removeEventListener("touchmove", touchmove);
                canvas.removeEventListener("touchend", touchend);
                noevent(e);
            }
        });

        render();

    </script>
</body>
</html>